import { hostViewClassName } from '@angular/compiler/public_api';
import { Pipe, PipeTransform } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { Observable } from 'rxjs';
import { map, first } from 'rxjs/operators';

@Pipe({
name: 'ParamsTranslate'
})
export class ParamsTranslatePipe implements PipeTransform {
constructor(private _translate: TranslateService) {}
// private translation: string | null = null;
// private getTranslation(key: string): any {
//        this._translate
//       .get(key);
//   }
  async getRolestypes(obj:string): Promise<any> {
    return  this._translate.get(obj).toPromise();
 }
  getRolestypes1(obj:string,newObject:any): Promise<any> {
    return this._translate.get(obj, newObject).//'{param1: "Value 1", param2: "Value 2"}').
    toPromise()
 }
  
 transform(obj: string, ...args: any[]) : string {
    const newObject = Object.assign({}, ...args); 
    
    Object.keys(newObject).forEach(
        key =>
        newObject[key].length
                ? this._translate
                      .get(newObject[key])
                      .pipe(first(), map(value => value))
                      .subscribe(value => (newObject[key] = value))
                : undefined
    );
    this._translate.get(obj, newObject).pipe(map(res => { // changed the subscribe
        // let userData; // scoping it inside the return
        // userData = res;
        console.log(res);
        // if (true) {
          return 'userData';
        // } else {
          
        //   return 'prop';
        // }
      }));
    //  let ff  = await this.getRolestypes(obj)
    //  console.log(ff)  
    //  console.log(newObject)
    //  let ff  = this.getRolestypes1(obj,newObject)
    //  ff.then((value) => {
    //     console.log(value); // 👉️ "Hello world"
      
    //     return value;
    //   });
     //return '88'
    // let gg ='{param1: "Value 1", param2: "Value 2"}'
    //const result = await this._translate.get(obj);
    //let f =  await this.getRolestypes1(obj,newObject)
    //console.log(f )
    // return new Promise(resolve => {
    //     resolve(this.getRolestypes1(obj,newObject));
    // });
  //console.log(result)
 //   return f// this.getRolestypes1(obj,newObject)
    //this._translate.instant(obj, newObject)

    // this.getTranslation(obj);

    // console.log(this.translation)
    // return this._translate.get(this.translation, newObject)
  
    // const result=''
    // this._translate.get(obj, newObject).subscribe((res: string) => {
    //     console.log(res);
    //     //=> 'hello world'
    // })
    // this._translate
    // .get(obj)
    // .subscribe(value => {
        
    //      this.result =  this._translate.instant(quvalue,this.newObjectery);
    // })
 //   return ff;
}
}
https://stackoverflow.com/questions/64244497/conditional-data-binding-in-angular-with-piped-translate-variables
https://stackoverflow.com/questions/57733188/how-to-use-i18n-with-component-inputs-that-are-objects-in-angular
https://www.npmjs.com/package/pretty-ngx-translate
   <div ng-controller="Ctrl">
      <p>{{ 'HEADLINE' | translate }}</p>
      <img src="mylogo.png" translate-attr="{ alt: 'LOGO' }"></img>
      <p>{{ 'PARAGRAPH' | translate }}</p>
    
      <p translate>PASSED_AS_TEXT</p>
      <p translate="PASSED_AS_ATTRIBUTE"></p>
      <p translate>{{ 'PASSED_AS_INTERPOLATION' }}</p>
      <p translate="{{ 'PASSED_AS_INTERPOLATION' }}"></p>
    </div>

]

https://github.com/ngx-translate/core/issues/570





https://www.9lessons.info/2020/10/angular-internationalization-multi-langu.html
https://testing-angular.com/testing-pipes/
<element>{{ 'KEY' | translate }}</element>
<element title="{{ 'KEY' | translate }}"></element>
<element [title]="property | translate"></element>
https://stackblitz.com/edit/angular-multi-language-with-translate-pipe?file=src%2Fapp%2Ftranslate.pipe.ts
https://stackblitz.com/edit/stackoverflow-53029885?file=src%2Fapp%2Fmissing-translation.ts
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable, Optional } from '@angular/core';
import { delay, Observable, of } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class DocumentService {
  constructor(@Optional() @Inject(DOCUMENT) private document: Document) {}

  getBody() {
    return this.document.body;
  }

  getPeople(): Observable<string> {
    return of('kkkkk').pipe(delay(5000));
}

  getCookie() {
    let k=''
    this.delay(5000).then(() =>  {
      k= 'oo';
    console.log('ran after 1 second1 passed')
  });
    
  return k
  }

  delay(time) {
    return new Promise(resolve => setTimeout(resolve, time));
  }
}

import { APP_INITIALIZER, NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';

import { AppComponent } from './app.component';
import { HelloComponent } from './hello.component';
import { DocumentService } from './document.service';
import { DOCUMENT } from '@angular/common';

@NgModule({
  imports: [BrowserModule, FormsModule],
  declarations: [AppComponent, HelloComponent],
  bootstrap: [AppComponent],
  providers: [
    {
      provide: APP_INITIALIZER,
      deps: [DocumentService],
      useFactory: (document: DocumentService) => (): any => {

        document.getPeople().subscribe(data => console.log(data));
        console.log(document.getPeople());
      },
      multi: true,
    },
  ],
})
export class AppModule {}


import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';

import { LoggerService } from './logger.service';

import { AppComponent } from './app.component';
import { HelloComponent } from './hello.component';

// service Factory
const loggerFactory = () => {
  const isProd = false; // you can use Angular `environment` variables
  console.log('oo')
  var getJSON = localStorage.getItem('lastname');
    if (getJSON){
      console.log(getJSON)
        return new LoggerService(isProd);

    }
  return new LoggerService(isProd);
}
@NgModule({
  imports:      [ BrowserModule, FormsModule ],
  declarations: [ AppComponent, HelloComponent ],
  providers: [
    {
      provide: LoggerService,
      useFactory: loggerFactory
    }
  ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }


https://stackblitz.com/edit/angular-factory-provider-demo?file=src%2Fapp%2Fapp.module.ts,src%2Fapp%2Flogger.service.ts,src%2Findex.html,src%2Fapp%2Fapp.component.ts,src%2Fapp%2Fhello.component.ts

using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Features;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Net.Http.Headers;
using System;
using System.IO;
using System.Linq;
using System.Net;
using System.Threading.Tasks;

namespace WebApplication4
{
    
    public class VideoStreamResult : FileStreamResult
    {
        // default buffer size as defined in BufferedStream type
        private const int BufferSize = 0x1000;
        private string MultipartBoundary = "<qwe123>";

        public VideoStreamResult(Stream fileStream, string contentType)
            : base(fileStream, contentType)
        {

        }

        public VideoStreamResult(Stream fileStream, MediaTypeHeaderValue contentType)
            : base(fileStream, contentType)
        {

        }

        private bool IsMultipartRequest(RangeHeaderValue range)
        {
            return range != null && range.Ranges != null && range.Ranges.Count > 1;
        }

        private bool IsRangeRequest(RangeHeaderValue range)
        {
            return range != null && range.Ranges != null && range.Ranges.Count > 0;
        }

        protected async Task WriteVideoAsync(HttpResponse response)
        {
            var bufferingFeature = response.HttpContext.Features.Get<dynamic>();
            bufferingFeature?.DisableBuffering();

            var length = FileStream.Length;

            var range = GetRanges(response.HttpContext,length);

            if (IsMultipartRequest(range))
            {
                response.ContentType = $"multipart/byteranges; boundary={MultipartBoundary}";
            }
            else
            {
                response.ContentType = ContentType.ToString();
            }

            response.Headers.Add("Accept-Ranges", "bytes");

            if (IsRangeRequest(range))
            {
                response.StatusCode = (int)HttpStatusCode.PartialContent;

                if (!IsMultipartRequest(range))
                {
                    response.Headers.Add("Content-Range", $"bytes {range.Ranges.First().From}-{range.Ranges.First().To}/{length}");
                }

                foreach (var rangeValue in range.Ranges)
                {
                    if (IsMultipartRequest(range)) // dunno if multipart works
                    {
                        await response.WriteAsync($"--{MultipartBoundary}");
                        await response.WriteAsync(Environment.NewLine);
                        await response.WriteAsync($"Content-type: {ContentType}");
                        await response.WriteAsync(Environment.NewLine);
                        await response.WriteAsync($"Content-Range: bytes {range.Ranges.First().From}-{range.Ranges.First().To}/{length}");
                        await response.WriteAsync(Environment.NewLine);
                    }

                    await WriteDataToResponseBody(rangeValue, response);

                    if (IsMultipartRequest(range))
                    {
                        await response.WriteAsync(Environment.NewLine);
                    }
                }

                if (IsMultipartRequest(range))
                {
                    await response.WriteAsync($"--{MultipartBoundary}--");
                    await response.WriteAsync(Environment.NewLine);
                }
            }
            else
            {
                await FileStream.CopyToAsync(response.Body);
            }
        }

        private async Task WriteDataToResponseBody(RangeItemHeaderValue rangeValue, HttpResponse response)
        {
            var startIndex = rangeValue.From ?? 0;
            var endIndex = rangeValue.To ?? 0;

            byte[] buffer = new byte[BufferSize];
            long totalToSend = endIndex - startIndex;
            int count = 0;

            long bytesRemaining = totalToSend + 1;
            response.ContentLength = bytesRemaining;

            FileStream.Seek(startIndex, SeekOrigin.Begin);

            while (bytesRemaining > 0)
            {
                try
                {
                    if (bytesRemaining <= buffer.Length)
                        count = FileStream.Read(buffer, 0, (int)bytesRemaining);
                    else
                        count = FileStream.Read(buffer, 0, buffer.Length);

                    if (count == 0)
                        return;

                    await response.Body.WriteAsync(buffer, 0, count);

                    bytesRemaining -= count;
                }
                catch (IndexOutOfRangeException)
                {
                    await response.Body.FlushAsync();
                    return;
                }
                finally
                {
                    await response.Body.FlushAsync();
                }
            }
        }

        public override async Task ExecuteResultAsync(ActionContext context)
        {
            await WriteVideoAsync(context.HttpContext.Response);
        }
        public RangeHeaderValue GetRanges(HttpContext context, long contentSize)
        {
            RangeHeaderValue rangesResult = null;

            string rangeHeader = context.Request.Headers["Range"];

            if (!string.IsNullOrEmpty(rangeHeader))
            {
                string[] ranges = rangeHeader.Replace("bytes=", string.Empty).Split(",".ToCharArray());

                rangesResult = new RangeHeaderValue();

                for (int i = 0; i < ranges.Length; i++)
                {
                    const int START = 0, END = 1;

                    long endByte, startByte;

                    long parsedValue;

                    string[] currentRange = ranges[i].Split("-".ToCharArray());

                    if (long.TryParse(currentRange[END], out parsedValue))
                        endByte = parsedValue;
                    else
                        endByte = contentSize - 1;


                    if (long.TryParse(currentRange[START], out parsedValue))
                        startByte = parsedValue;
                    else
                    {
                        startByte = contentSize - endByte;
                        endByte = contentSize - 1;
                    }

                    rangesResult.Ranges.Add(new RangeItemHeaderValue(startByte, endByte));
                }
            }

            return rangesResult;
        }
    }

    
}
  var filepath = @"c:\vm\vo\1280.mp4";
            var stream = new FileStream(filepath, FileMode.Open, FileAccess.Read);
            return new VideoStreamResult(stream, "video/mp4");
onLaunch12() {
    const id = document.getElementById('1112234234');
    if (id) {
      id.scrollIntoView();
    }
    console.log('p')
     document.getElementById('content1').scrollTo(50,50)
  }
  
   <clr-dg-row [attr.id] ="element.key" [clrDgItem]="element" *clrDgItems="let element of elements"  >

<button class="btn btn-sm btn-success" (click)="onLaunch1()"> Launch</button>
<div class="main-container">
  <header class="header-2">
    <div class="branding">
      <a class="nav-link">
        <clr-icon shape="home" size="24"></clr-icon>
        <span class="title">Project Clarity</span>
      </a>
    </div>
    <div class="header-nav">
      <a class="active nav-link nav-text">Home</a>
    </div>
  </header>
  <div class="content-container">
    <div class="content-area">
      <clr-datagrid [(clrDgSelected)]="selected">
        <clr-dg-column>ID2</clr-dg-column>
        <clr-dg-column>Name</clr-dg-column>
        
        <cdk-virtual-scroll-viewport  style="height: 350px" itemSize="16">
        <clr-dg-row *cdkVirtualFor="let user of users" [clrDgItem]="user">
        <clr-dg-cell>{{ user.id }}</clr-dg-cell>
        <clr-dg-cell>{{ user.name }}</clr-dg-cell>
        </clr-dg-row>
    </cdk-virtual-scroll-viewport>

    <!--  <cdk-virtual-scroll-viewport class="list-container lg" customVirtualScrollStrategy [itemSize]="16">
        <clr-dg-row *clrDgItems="let user of users" [clrDgItem]="user">
        <clr-dg-cell>{{ user.id }}</clr-dg-cell>
        <clr-dg-cell>{{ user.name }}</clr-dg-cell>
      </clr-dg-row>
       
      </cdk-virtual-scroll-viewport>-->   
      <clr-dg-placeholder>We couldn't load any launches</clr-dg-placeholder>
      <clr-dg-footer>
      {{pagination.firstItem + 1}} - {{pagination.lastItem + 1}}
      of {{pagination.totalItems}} launches
      <clr-dg-pagination #pagination [clrDgPageSize]="10" [clrDgTotalItems]="response?.total"></clr-dg-pagination>
    </clr-dg-footer>

       
       
      </clr-datagrid>
    </div>
  </div>
</div>


import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { FormsModule } from '@angular/forms';
import { ClrCheckboxDisplayDirective } from './clr-checkbox-display.directive';

import { ClarityModule } from '@clr/angular';

import { AppComponent } from './app.component';
import { ScrollingModule } from '@angular/cdk-experimental/scrolling';
import { ScrollDispatchModule } from '@angular/cdk/scrolling';

@NgModule({
  imports: [BrowserModule, BrowserAnimationsModule, ClarityModule, FormsModule, ScrollDispatchModule, ScrollingModule],
  exports: [ClrCheckboxDisplayDirective],
  declarations: [AppComponent, ClrCheckboxDisplayDirective],
  bootstrap: [AppComponent]
})
export class AppModule { }


.datagrid-placeholder-container {
  display: none;
}


import { CdkVirtualScrollViewport } from '@angular/cdk-experimental/scrolling';
import { Component, ViewChild } from '@angular/core';
import { Router } from '@angular/router';
@Component({
  selector: 'my-app',
  styleUrls: ['app.component.css'],
  templateUrl: 'app.component.html'
})
export class AppComponent {
  @ViewChild(CdkVirtualScrollViewport)
  cdkVirtualScrollViewport: CdkVirtualScrollViewport;
  selected: any = [];
  users = [
    {
      "id": 0,
      "name": "Newton"
    },
    {
      "id": 1,
      "name": "Edison"
    }, {
      "id": 2,
      "name": "Newton"
    },
    {
      "id": 3,
      "name": "Edison"
    },{
      "id": 4,
      "name": "Newton"
    },
    {
      "id": 5,
      "name": "Edison"
    }, {
      "id": 6,
      "name": "Newton"
    },
    {
      "id": 7,
      "name": "Edison"
    }, {
      "id": 8,
      "name": "Newton"
    },
    {
      "id": 9,
      "name": "Edison"
    }, {
      "id":10,
      "name": "Newton"
    },
    {
      "id":11,
      "name": "Edison"
    }, {
      "id":12,
      "name": "Newton"
    },
    {
      "id": 13,
      "name": "Edison"
    } ,{
      "id": 14,
      "name": "Newton"
    },
    {
      "id": 15,
      "name": "Edison"
    }
  ]
  scrollTo() { 
    this.cdkVirtualScrollViewport.scrollToIndex(10);
  }
  onLaunch1() {
    this.cdkVirtualScrollViewport.scrollToIndex(11, 'auto');
   // console.log( this.cdkVirtualScrollViewport.)
  }
}
