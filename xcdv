
using Microsoft.AspNetCore.StaticFiles;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Xml;
using System.Xml.Linq;

namespace webdavconsole
{
    class Program
    {
        public static readonly string baseUri = "http://localhost:19080/";
        public static readonly string directory = @"C:\WebDavRoot\vr\";
        public static readonly XNamespace DavNs = "DAV:";
        public static readonly string DavNsPrefix = "D";


        static void Main(string[] args)
        {

            HttpListener listener = new HttpListener();
            listener.Prefixes.Add(baseUri);
            //  listener.AuthenticationSchemes = AuthenticationSchemes.Basic;
            //string username = "advtek09.jn";
            //string password = "1qaz2wsxC";
            //listener.AuthenticationSchemeSelectorDelegate = new AuthenticationSchemeSelector(AuthenticationSchemeForClient);
            //listener.AuthenticationSchemes = AuthenticationSchemes.IntegratedWindowsAuthentication;

            //listener.AuthenticationSchemes = AuthenticationSchemes.Basic;

            listener.Realm = "WebDAV server";
            listener.Start();
            Console.WriteLine("WebDAV server running...");


            try
            {
                while (true)
                {
                    HttpListenerContext context = listener.GetContext();
                    HttpListenerRequest request = context.Request;
                    HttpListenerResponse response = context.Response;

                    Console.WriteLine("Request: {0} {1}", request.HttpMethod, request.RawUrl);
                    //string fullPath = rootPath + request.Url.LocalPath;

                    //FileInfo fileInfo = new FileInfo(fullPath);
                    var url = "vr";// request.Url.AbsolutePath.TrimEnd('/');
                    var filePath = Path.Combine(directory, url);
                    // filePath = @"C:\\WebDavRoot\\vr\\z.xlsx";
                    //var dept = "OA-MARS02";
                    //var fileid = "63ed1c05-3232-4904-b265-52258b0179d0";
                    //filePath = string.Format(@"\\10.55.9.77\PDOCS$\TN002\{0}\DOCUMENTS\{1}\{2}", dept, dept, fileid);
                    if (request.HttpMethod == "GET")
                    {
                        string path = request.Url.LocalPath;
                        path = path.TrimStart('/').Replace("/", "\\");
                        filePath = Path.Combine(directory, path);

                        if (File.Exists(filePath))
                        {
                            response.ContentType = GetMimeType(filePath);
                            response.ContentLength64 = new FileInfo(filePath).Length;

                            using (var stream = new FileInfo(filePath).OpenRead())
                            {
                                stream.CopyTo(response.OutputStream);
                            }

                            response.StatusCode = (int)HttpStatusCode.OK;
                        }
                        response.Close();
                    }
                    else if (request.HttpMethod == "PUT")
                    {
                        string overwriteHeader = request.Headers.Get("Overwrite");
                        string path = request.Url.LocalPath;
                        path = path.TrimStart('/').Replace("/", "\\");
                        filePath = Path.Combine(directory, path);
                        bool fileExists = File.Exists(filePath);
                        if (fileExists && overwriteHeader == "T")
                        {
                            // Delete the existing file
                            File.Delete(filePath);

                            // Write the new file
                            using (Stream input = request.InputStream)
                            {
                                using (FileStream output = File.Create(filePath))
                                {
                                    input.CopyTo(output);
                                }
                            }
                            //using (FileStream fs = new FileStream(filePath, FileMode.Create))
                            //{
                            //    request.InputStream.CopyTo(fs);
                            //    response.StatusCode = (int)HttpStatusCode.Created;
                            //}
                            // Send a success response
                            response.StatusCode = (int)HttpStatusCode.OK;
                            response.StatusDescription = "OK";
                        }
                        else if (fileExists && overwriteHeader == "F")
                        {
                            // Send a 412 Precondition Failed response
                            response.StatusCode = (int)HttpStatusCode.PreconditionFailed;
                            response.StatusDescription = "Precondition Failed";
                        }
                        else if (fileExists && overwriteHeader != null)
                        {
                            // Invalid value for Overwrite header
                            response.StatusCode = (int)HttpStatusCode.BadRequest;
                            response.StatusDescription = "Bad Request";
                        }
                        else
                        {
                            // Write the new file
                            using (Stream input = request.InputStream)
                            {
                                using (FileStream output = File.Create(filePath))
                                {
                                    input.CopyTo(output);
                                }
                            }

                            // Send a success response
                            response.StatusCode = (int)HttpStatusCode.OK;
                            response.StatusDescription = "OK";
                        }

                      
                        response.Close();

                        ////string filePath = request.Url.LocalPath.Substring(1);
                        //filePath = @"C:\\WebDavRoot\\vr\\z.xlsx";
                        //byte[] contentBytes = new byte[request.ContentLength64];
                        //request.InputStream.Read(contentBytes, 0, contentBytes.Length);
                        //string content = Encoding.UTF8.GetString(contentBytes);

                        //Console.WriteLine("Received content: {0}", content);

                        //using (FileStream fileStream = new FileStream(filePath, FileMode.Create))
                        //{
                        //    fileStream.Write(contentBytes, 0, contentBytes.Length);
                        //}

                        //response.StatusCode = 201;
                        //response.StatusDescription = "Created";
                    }
                    else if (request.HttpMethod == "OPTIONS")
                    {
                        response.Headers.Add("Allow", "OPTIONS, TRACE, GET, HEAD, POST, COPY, PROPFIND, DELETE, PUT,MOVE, PROPPATCH, MKCOL, LOCK, UNLOCK");
                        response.Headers.Add("Public", "OPTIONS, TRACE, GET, HEAD, POST, PROPFIND, PROPPATCH, MKCOL, PUT, DELETE, COPY, MOVE, LOCK, UNLOCK");
                        response.Headers.Add("MS-Author-Via", "DAV");
                        response.Headers.Add("DAV", "1,2,3");
                        response.StatusCode = 200;
                        response.Close();
                    }
                    else if (request.HttpMethod == "POST")
                    {
                    }
                    else if (request.HttpMethod == "HEAD")
                    {
                        string path = request.Url.LocalPath;
                        path = path.TrimStart('/').Replace("/", "\\");
                        filePath = Path.Combine(directory, path);
                        // Get file info
                        FileInfo fileInfo = new FileInfo(filePath);
                        response.ContentLength64 = fileInfo.Length;
                        response.ContentType = GetMimeType(filePath);
                        string etag = fileInfo.Length.ToString();
                        response.AddHeader("ETag", "\"" + etag + "\"");
                        response.Headers.Add(HttpResponseHeader.LastModified, fileInfo.LastWriteTimeUtc.ToString("r"));
                        response.StatusCode = (int)HttpStatusCode.OK;
                        response.Close();
                    }
                    else if (context.Request.HttpMethod == "LOCK")
                    {
                        string requestUrl = request.Url.ToString();
                        string lockToken = Guid.NewGuid().ToString();

                        // Check if the resource is already locked
                        if (IsLocked(requestUrl))
                        {
                            // Resource is already locked, return 423 Locked status code
                            response.StatusCode = (int)HttpStatusCode.Locked;
                            response.Close();
                            return;
                        }

                        //// Parse the lock request XML
                        //XmlDocument xmlDoc = new XmlDocument();
                        //xmlDoc.Load(context.Request.InputStream);
                        //XmlNamespaceManager namespaceManager = new XmlNamespaceManager(xmlDoc.NameTable);
                        //namespaceManager.AddNamespace("D", "DAV:");
                        //XmlNode lockScopeNode = xmlDoc.SelectSingleNode("//D:lockscope/D:exclusive", namespaceManager);
                        //XmlNode lockTypeNode = xmlDoc.SelectSingleNode("//D:locktype/D:write", namespaceManager);
                        //XmlNode ownerNode = xmlDoc.SelectSingleNode("//D:owner", namespaceManager);

                        //// Set the lock timeout
                        //int lockTimeout = 0;
                        //string timeoutHeader = context.Request.Headers.Get("Timeout");
                        //if (!string.IsNullOrEmpty(timeoutHeader) && timeoutHeader.StartsWith("Second-"))
                        //{
                        //    int.TryParse(timeoutHeader.Substring(7), out lockTimeout);
                        //}

                        // Create the lock info
                        //LockInfo lockInfo = new LockInfo();
                        //lockInfo.ResourceUrl = requestUrl;
                        //lockInfo.LockScope = lockScopeNode != null ? LockScope.Exclusive : LockScope.Shared;
                        //lockInfo.LockType = lockTypeNode != null ? LockType.Write : LockType.Read;
                        //lockInfo.Owner = ownerNode != null ? ownerNode.InnerText : null;
                        //lockInfo.Timeout = lockTimeout;
                        //lockInfo.LockToken = lockToken;
                        //lockInfo.LockTime = DateTime.UtcNow;

                        //// Add the lock to the locked resources dictionary
                        //_lockedResources.Add(requestUrl, lockInfo);

                        // Set the lock token header in the response
                        response.AddHeader("Lock-Token", $"<urn:uuid:{lockToken}>");

                        // Return 200 OK status code
                        response.StatusCode = (int)HttpStatusCode.OK;
                        response.Close();

                    }
                    else if (context.Request.HttpMethod == "UNLOCK")
                    {
                        string lockToken = context.Request.Headers["Lock-Token"];

                        if (string.IsNullOrEmpty(lockToken))
                        {
                            context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                            return;
                        }

                        // TODO: Validate the lock token and perform any necessary unlocking logic

                        context.Response.StatusCode = (int)HttpStatusCode.NoContent;
                        response.Close();
                    }
                    else if (context.Request.HttpMethod == "DELETE")
                    {
                        filePath = Path.Combine(directory, request.Url.LocalPath.TrimStart('/').Replace("/", "\\"));
                        if (File.Exists(filePath))
                        {
                            try
                            {
                                File.Delete(filePath);
                                response.StatusCode = (int)HttpStatusCode.OK;
                            }
                            catch (Exception)
                            {
                                response.StatusCode = (int)HttpStatusCode.InternalServerError;
                            }
                        }
                        else
                        {
                            response.StatusCode = (int)HttpStatusCode.NotFound;
                        }
                        response.Close();
                    }
                    else if (context.Request.HttpMethod == "MOVE")//目前只能改檔名
                    {
                        string sourceFilePath = Path.Combine(directory, request.Url.LocalPath.TrimStart('/').Replace("/", "\\"));
                        string destinationFilePath = Path.Combine(directory, request.Headers["Destination"].Replace(request.Url.Scheme + "://" + request.Url.Host + ":" + request.Url.Port, "").TrimStart('/').Replace("/", "\\"));

                        try
                        {
                            if (Directory.Exists(sourceFilePath) && !Directory.Exists(destinationFilePath))
                            {
                                Directory.Move(sourceFilePath, destinationFilePath);
                                response.StatusCode = (int)HttpStatusCode.Created;
                            }
                            else
                            {
                                if (!File.Exists(sourceFilePath))
                                {
                                    response.StatusCode = (int)HttpStatusCode.NotFound;
                                    response.Close();
                                    continue;
                                }

                                if (File.Exists(destinationFilePath))
                                {
                                    response.StatusCode = (int)HttpStatusCode.Conflict;
                                    response.Close();
                                    continue;
                                }

                                File.Move(sourceFilePath, destinationFilePath);

                                //File.Copy(sourceFilePath, destinationFilePath);
                                //File.Delete(sourceFilePath);
                                response.StatusCode = (int)HttpStatusCode.Created;
                                //response.Headers["Location"] = $"{baseUri}{request.Url.LocalPath.TrimStart('/')}";
                                //context.Response.AddHeader("Location", context.Request.Headers["Destination"]);

                            }
                        }
                        catch (Exception)
                        {
                            response.StatusCode = (int)HttpStatusCode.InternalServerError;
                        }
                        response.Close();
                    }
                    else if (context.Request.HttpMethod == "MKCOL")
                    { 
                        string newCollection = Path.Combine(directory, request.Url.LocalPath.TrimStart('/').Replace("/", "\\"));
                        // Create the new directory
                        System.IO.Directory.CreateDirectory(newCollection);

                        // Send a response
                        context.Response.StatusCode = (int)HttpStatusCode.Created;
                        context.Response.Close();
                    }
                    else if (context.Request.HttpMethod == "COPY")
                    {

                        string sourceFilePath = Path.Combine(directory, request.Url.LocalPath.TrimStart('/').Replace("/", "\\"));
                        string destinationFilePath = Path.Combine(directory, request.Headers["Destination"].Replace(request.Url.Scheme + "://" + request.Url.Host + ":" + request.Url.Port, "").TrimStart('/').Replace("/", "\\"));

                        // Check if the destination file already exists
                        if (File.Exists(destinationFilePath))
                        {
                            context.Response.StatusCode = (int)HttpStatusCode.Conflict;
                            context.Response.Close();
                            return;
                        }

                        // Copy the file to the destination
                        try
                        {
                            File.Copy(sourceFilePath, destinationFilePath);
                            response.StatusCode = (int)HttpStatusCode.Created;
                        }
                        catch (IOException)
                        {
                            response.StatusCode = (int)HttpStatusCode.InternalServerError;
                        }

                        response.Close();

                    }
                    else if (context.Request.HttpMethod == "PROPPATCH")
                    { 
                    
                    }
                    else if (context.Request.HttpMethod == "PROPFIND")
                    {
                        if (context.Request.Headers["Depth"] == "0")
                        {
                            //response.StatusCode = (int)HttpStatusCode.Unauthorized;
                            //response.Close();
                        }
                        // Get the path requested by the client
                        string path = request.Url.LocalPath;

                        //if (path == "/")
                        //{
                        //    response.StatusCode = (int)HttpStatusCode.Unauthorized;
                        //    response.Close();
                        //}
                        //else
                        //{
                        if (path == "/")
                        {
                            path = directory + path.TrimStart('/').Replace("/", "\\");
                        }
                        else if (path.Contains('.'))
                        {
                            path = Path.Combine(directory, Path.GetDirectoryName(path.TrimStart('/').Replace("/", "\\")));

                            //directory;// + path.TrimStart('/').Replace("/", "\\");
                        }
                        else if (path.StartsWith("/"))
                        {
                            path = directory + path.TrimStart('/').Replace("/", "\\");
                        }

                        //else
                        //{
                        //    if (path.StartsWith("/"))
                        //    {
                        //        path = directory + path.TrimStart('/').Replace("/", "\\");
                        //    }

                        //}

                        // Check if the path is a directory
                        bool isDir = Directory.Exists(path);
                        bool isFile = false;
                        // If the path is not a directory, check if it is a file
                        if (!isDir)
                        {
                            isFile = File.Exists(path);
                        }

                        // If the path is neither a directory nor a file, return 404 Not Found
                        if (!isDir && !isFile)
                        {
                            response.StatusCode = (int)HttpStatusCode.NotFound;
                            return;
                        }


                        var xMultiStatus = new XElement(DavNs + "multistatus");
                        var xml = new XDocument(xMultiStatus);

                        // Add a response element for the directory or file
                        //xml.Root.Add(CreateResponseElement(path, isDir));

                        // If the path is a directory, add response elements for the directory's files
                        if (isDir)
                        {
                            //string[] files = Directory.GetFiles(path);
                            DirectoryInfo directory = new DirectoryInfo(path);
                            var files = directory.GetFiles().Where(f => !f.Attributes.HasFlag(FileAttributes.Hidden));

                            // var filtered = files.Where(f => !IsHidden(File.GetAttributes(f).ToString()));

                            string[] dirs = Directory.GetDirectories(path);
                            if (files.Count() > 0 || dirs.Length>0)
                            {
                                xml.Root.Add(CreateResponseElement(path, true, false));
                            }
                            foreach (var file in files)
                            {
                                xml.Root.Add(CreateResponseElement(file.FullName, false));
                            }
                            foreach (string dir in dirs)
                            {
                                xml.Root.Add(CreateResponseElement(dir, true));
                            }
                            if (files.Count() == 0 && dirs.Length == 0)
                            {
                                xml.Root.Add(CreateResponseElement(path, true, true));
                            }
                        }
                        if (isFile)
                        {
                            xml.Root.Add(CreateResponseElement(path, false));
                        }

                        byte[] bodyBytes = Encoding.UTF8.GetBytes(xml.ToString());
                        response.StatusCode = 207; // Multi-Status
                        response.ContentType = "text/xml";
                        response.ContentLength64 = bodyBytes.Length;
                        response.OutputStream.Write(bodyBytes, 0, bodyBytes.Length);

                        //}
                    }
                    else
                    {
                        response.StatusCode = 405;
                        response.Close();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

        private static XElement CreateResponseElement(string path, bool isDir, bool blast = false)
        {
            string href = baseUri + path.Replace(directory, "").Replace('\\', '/');
            string displayName = Path.GetFileName(path);
            XElement response = null;

            if (blast)
            {
                response = new XElement(DavNs + "response",
                   new XElement(DavNs + "href", href),
                   new XElement(DavNs + "propstat",
                       new XElement(DavNs + "prop",
                           new XElement(DavNs + "displayname", ""),
                           new XElement(DavNs + "getlastmodified", ""),
                           new XElement(DavNs + "getlastaccessed", ""),
                           new XElement(DavNs + "creationdate", ""),
                           new XElement(DavNs + "getcontentlength", "0"),
                           new XElement(DavNs + "getcontenttype", ""),
                           new XElement(DavNs + "resourcetype", "")),
                       new XElement(DavNs + "status", "HTTP/1.1 200 OK"))
                   );
            }
            else
            {
                response = new XElement(DavNs + "response",
                    new XElement(DavNs + "href", href),
                    new XElement(DavNs + "propstat",
                        new XElement(DavNs + "prop",
                            new XElement(DavNs + "displayname", displayName),
                            new XElement(DavNs + "getlastmodified", File.GetLastWriteTimeUtc(path).ToString("R")),
                            new XElement(DavNs + "getlastaccessed", File.GetLastAccessTimeUtc(path).ToString("R")),
                            new XElement(DavNs + "creationdate", File.GetCreationTimeUtc(path).ToString("R")),
                            new XElement(DavNs + "getcontentlength", isDir ? "0" : new FileInfo(path).Length.ToString()),
                            new XElement(DavNs + "getcontenttype", isDir ? "httpd/unix-directory" : GetMimeType(path)),
                            new XElement(DavNs + "resourcetype", isDir ? new XElement(DavNs + "collection") : null)),
                        new XElement(DavNs + "status", "HTTP/1.1 200 OK")));

            }
            return response;
        }

        public static string GetMimeType(string fileName)
        {
            var provider = new FileExtensionContentTypeProvider();
            if (!provider.TryGetContentType(fileName, out string mimeType))
            {
                mimeType = "application/octet-stream";
            }
            return mimeType;
        }

        static XmlElement CreateElement(XmlElement parent, string name, string ns, string value)
        {
            XmlElement element = parent.OwnerDocument.CreateElement(name, ns);
            element.InnerText = value;
            return element;
        }
        private static XmlElement CreateResponseElement(XmlDocument responseXml, string path)
        {
            XmlElement response = responseXml.CreateElement("D:response", "DAV:");
            XmlElement href = responseXml.CreateElement("D:href", "DAV:");
            href.InnerText = path;
            response.AppendChild(href);
            return response;
        }

        private static void AddDirectoryProperties(XmlElement response, string path)
        {
            DirectoryInfo directory = new DirectoryInfo(path);
            response.AppendChild(CreateElement(response, "D:resourcetype", "DAV:", "<D:collection/>"));
            response.AppendChild(CreateElement(response, "D:getlastmodified", "DAV:", directory.LastWriteTimeUtc.ToString("R")));
            response.AppendChild(CreateElement(response, "D:getcontenttype", "DAV:", "httpd/unix-directory"));
            response.AppendChild(CreateElement(response, "D:getcontentlength", "DAV:", "0"));
        }

        private static void AddFileProperties(XmlElement response, string path)
        {
            FileInfo file = new FileInfo(path);
            response.AppendChild(CreateElement(response, "D:resourcetype", "DAV:", ""));
            response.AppendChild(CreateElement(response, "D:getlastmodified", "DAV:", file.LastWriteTimeUtc.ToString("R")));
            response.AppendChild(CreateElement(response, "D:getcontenttype", "DAV:", "application/octet-stream"));
            response.AppendChild(CreateElement(response, "D:getcontentlength", "DAV:", file.Length.ToString()));
        }
        //static AuthenticationSchemes AuthenticationSchemeForClient(HttpListenerRequest request)
        //{
        //    if (request.Headers["Authorization"] != null && request.Headers["Authorization"].StartsWith("Basic"))
        //    {
        //        string credentials = Encoding.ASCII.GetString(Convert.FromBase64String(request.Headers["Authorization"].Substring(6)));
        //        string[] parts = credentials.Split(':');
        //        string username = parts[0];
        //        string password = parts[1];

        //        // Check username and password against database or other authentication method
        //        if (username == "user1" && password == "pass123")
        //        {
        //            return AuthenticationSchemes.Basic;
        //        }
        //    }

        //    // No valid credentials found, so return 401 Unauthorized
        //    HttpListenerResponse response = context.Response;
        //    response.StatusCode = 401;
        //    response.AddHeader("WWW-Authenticate", "Basic realm=\"" + listener.Realm + "\"");
        //    response.OutputStream.Close();

        //    return AuthenticationSchemes.Anonymous;
        //}

        static bool IsLocked(string path)
        {
            return false;
        }



        //private void HandlePropfind(HttpListenerContext context)
        //{
        //    // Get the requested URL and parse it
        //    var url = new Uri(context.Request.Url.GetLeftPart(UriPartial.Path));
        //    var depth = context.Request.Headers["Depth"];
        //    var infiniteDepthMode = depth == "infinity";

        //    // Create the XML document that will contain the properties
        //    var doc = new XDocument(new XDeclaration("1.0", "utf-8", "no"));
        //    var multistatus = new XElement(WebDavXml.Dav + "multistatus");
        //    doc.Add(multistatus);

        //    // If the URL represents a directory, add its contents to the response
        //    if (Directory.Exists(url.LocalPath))
        //    {
        //        var dirInfo = new DirectoryInfo(url.LocalPath);
        //        foreach (var subDir in dirInfo.GetDirectories())
        //        {
        //            var responseElement = CreateResponseElement(doc, $"{url}/{subDir.Name}/");
        //            multistatus.Add(responseElement);
        //        }
        //        foreach (var file in dirInfo.GetFiles())
        //        {
        //            var responseElement = CreateResponseElement(doc, $"{url}/{file.Name}");
        //            multistatus.Add(responseElement);
        //        }
        //    }
        //    else if (File.Exists(url.LocalPath))
        //    {
        //        // If the URL represents a file, add its properties to the response
        //        var responseElement = CreateResponseElement(doc, url.ToString());
        //        multistatus.Add(responseElement);
        //    }

        //    // Write the response to the output stream
        //    var responseBytes = Encoding.UTF8.GetBytes(doc.ToString());
        //    context.Response.ContentLength64 = responseBytes.Length;
        //    context.Response.ContentType = "text/xml";
        //    context.Response.OutputStream.Write(responseBytes, 0, responseBytes.Length);
        //    context.Response.OutputStream.Close();
        //}

        //private XElement CreateResponseElement(XDocument doc, string href)
        //{
        //    var response = new XElement(WebDavXml.Dav + "response",
        //        new XElement(WebDavXml.Dav + "href", href),
        //        new XElement(WebDavXml.Dav + "propstat",
        //            new XElement(WebDavXml.Dav + "status", "HTTP/1.1 200 OK"),
        //            new XElement(WebDavXml.Dav + "prop",
        //                new XElement(WebDavXml.Dav + "creationdate", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ssZ")),
        //                new XElement(WebDavXml.Dav + "getlastmodified", DateTime.Now.ToString("R")),
        //                new XElement(WebDavXml.Dav + "getcontenttype", "application/octet-stream"),
        //                new XElement(WebDavXml.Dav + "getcontentlength", "0")
        //            )
        //        )
        //    );
        //    return response;
        //}

    }
    public class info
    {
        public string type { get; set; }
        public string href { get; set; }
        public string getlastmodified { get; set; }
        public string getcontenttype { get; set; }
        public string getcontentlength { get; set; }
        public string status { get; set; }

        public string physicpath { get; set; }

        public string mountpath { get; set; }

        public string fileid { get; set; }

        public string filename { get; set; }
    }


    public class CurrentDir
    {

        public string baseDir { get; set; }

        public string parentpath { get; set; }
        public List<info> infos { get; set; }

        public int depth { get; set; }
    }
}
